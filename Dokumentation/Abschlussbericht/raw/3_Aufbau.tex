\chapter{Funktionsweise und Aufbau}
\label{ch:Aufbau}
Die Funktionsweise des Gestikulasers besteht aus der Detektion und Weiterverarbeitung von Lichtsignalen, welche mit einer Geste erzeugt werden. 

Dabei wird infrarotes Licht von einer LED Quelle durch die Hand reflektiert und mit Hilfe von mehreren Photodioden detektiert. Die durch die Photodioden erhaltenen Daten werden dann in einer Software weiterverarbeitet, welche mit Hilfe von Machine Learning die tatsächliche Handgeste erkennt. Von dort aus kann dann jedes beliebige Endgerät angesteuert werden.

Der Gestikulaser selbst besteht aus einer Platte, der Photoplatte, welche aus verschiedenen Steckmodulen zusammen gesteckt werden kann. Die Steckmodule bestehen aus einzelnen kleinen Boxen, in welche die Elektronik integriert ist. In der Mitte befindet sich der Oktokommander, welcher durch weitere Detektormodule erweitert werden kann. Auf jedes der Module befinden sich vier Photodioden um das reflektierte Licht zu messen. 


% -------------------------------------------------------------------------------------- %

\section{Oktokommander}
\label{sec:Oktokommander}

Ein Arduino Micro steuert den Oktokommander mittels eines I2C Bus an. Der I2C Bus benötigt lediglich 2 Pins auf dem Arduino, SDA für die eigentliche Datenverbindung und SCL für den vom Arduino vorgegebenen Takt. Jeder Sensor wird über eine, im System einzigartige, Hardware Adresse (I2C-Adresse) angesteuert.
Der Oktokommander erzeugt mittels eines I2C Expanders je 4 I2C Adressen die für die Zuordnung und Ansteuerung der einzelnen Verstärker benötigt werden.
Der I2C Multiplexer erhöht die Anzahl der verwendbaren I2C Expandermodulen, da diese intern maximal 4 unterschiedliche I2C Adressen erziehen können. Durch das multiplexen der vom Oktokommander erzeugten Adressen können so bis zu 1024 Sensoren angesteuert werden ohne das verschiedene Expandermodule verwendet werden müssen. 
\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{../figures/oktokommander.png}
	\caption{Schematischer Aufbau des Oktokommanders bestehend aus einem Arduino einem I2C Multiplexer, einem I2C Expander und einem Detektormodul}
	\label{fig:oktokommander}
\end{figure}
Um den Oktokommander mit den Detektormodulen erweitern zu können wurden USB-2A Schnittstellen verwendet. Durch diese Schnittstellen können bis zu 7 Detektormodule, jeweils eines pro Seite, angesteuert werden werden. Um eine größere Platte zu konstruieren, können noch weitere Detektormodule an den bereits vorhandenen Detektormodulen angeschlossen werden.


\subsubsection*{Konstruktion}
Die Unterbringung der Elektronik im Oktokommander erfolgt über drei sogenannte \textit{Stages}. Die Stages werden im Oktokommander übereinander angeordnet. Stage 1 ist in \reffig{fig:OktoStage1} dargestellt.

\begin{figure}[h]
	\centering
	\includegraphics[width=9cm]{../CAD_Bilder/OktagonElektronik_Stage1_raytraced.png}
	\caption{Stage 1 des Oktokommanders.}
	\label{fig:OktoStage1}
\end{figure}

Stage 1 ist eine Platine, auf der der Arduino Micro, die I2C-Expander, die Stromversorgung und die female USB-Buchsen zur Verbindung mit den Detektormodulen angeordnet sind. Stage 1 ist die unterste Elektronikeinheit im Oktokommander. Die LED-Einheit zur Lichterzeugung wird auf einer weiteren Plattform befestigt, die über der Stage 1 positioniert wird. Diese zweite Stage ist in \reffig{fig:OktoStage2} dargestellt.

\begin{figure}[h]
	\centering
	\includegraphics[width=9cm]{../CAD_Bilder/OktagonElektronik_Stage2_raytraced.png}
	\caption{Stage 2 des Oktokommanders.}
	\label{fig:OktoStage2}
\end{figure}

Die LED-Einheit besteht aus den vier LEDs, die auf einen Kühlkörper mit den Parabolzylindern geklebt werden. Zudem befinden sich die LED-Treiber auf der Stage 2. Die Aufnahme der LED-Einheit besteht aus einer dünnen Aluminiumplatte für den Wärmeabtransport. Die Bohrungen in der Aluminiumplatte dienen lediglich zur Durchführung der Kabel zur unteren Stage 1. Die oberste Stage 3 trägt vier Photodioden. In \reffig{fig:OktoStage3} ist die Stage 3 dargestellt.

\begin{figure}[h]
	\centering
	\includegraphics[width=9cm]{../CAD_Bilder/OktagonElektronik_Stage3_raytraced.png}
	\caption{Stage 3 des Oktokommanders.}
	\label{fig:OktoStage3}
\end{figure}

Die Stage 3 ist ein additiv gefertigtes Bauteil aus ABS-Kunststoff.

Die drei Stages werden im Gehäuse des Oktokommanders aufgenommen. In \reffig{fig:OktoZusammenbau} ist das Gehäuse mit dem Deckel und der Elektronik des Oktokommanders dargestellt.

\begin{figure}[h]
	\centering
	\includegraphics[width=9cm]{../CAD_Bilder/Oktokommander_raytraced.png}
	\caption{Zusammenbau des Oktokommanders.}
	\label{fig:OktoZusammenbau}
\end{figure}

Der Deckel und das Gehäuse des Oktokommanders werden additiv aus ABS-Kunststoff gefertigt.


% -------------------------------------------------------------------------------------- %

\section{Transimpedanzverstärker}
\label{sec:Transimpedanzverstärker}

Die Verstärkerschaltung besteht aus zwei sogenannten Transimpedanz Verstärkern. Der Aufbau besteht aus einem Operationsverstärker vom Typ LM358 und je zwei Widerständen und Kondensatoren sowie zwei Infrarot Photodioden (siehe \reffig{fig:Transimpedanz}).  
\begin{figure}[h]
	\centering
	\includegraphics[scale=0.75]{../figures/Transimpedanz.png}
	\caption{Schematische Darstellung des Transimpedanzverstärkersystems im Detektormodul}
	\label{fig:Transimpedanz}
\end{figure}
Die Photodiode fungiert in ihm als Konstantstromquelle, die einen kleinen Strom an das System abgibt. Mit Hilfe des Widerstandes $R_1$ und des Kondensators $C_1$ kann der Operationsverstärker (LM358) eine vom Mikrocontroller verarbeitbare hohe Spannung ausgeben. Wichtig ist hier die möglichst genaue Wahl der Kapazität $C_1$ ohne die das System anfangen würde zu Schwingen. Es ergibt sich:
\begin{align*}
	C_1 = \sqrt{\frac{C_I}{R_1 \cdot GBP}}
\end{align*}
Hierbei steht $GBP$ für \textit{Gain Bandwidth Product}. Sie ist die Frequenz, bei der keine Verstärkung mehr stattfindet. Sie ist somit die Obergrenze für einen praktikablen Einsatz des Systems Für den Operationsverstärker LM358 ist das $GBP$ mit $\unit[1]{MHz}$ im Datenblatt angegeben. $C_I$ ist die Summe der beiden Sperrschichtkapazitäten der Photodiode und des Operationsverstärkers. Typische Anwendungsgrößen für $R_1$ liegen bei etwa $\unit[1]{M\Omega}$. Der Arbeitsbereich des Verstärkersystems beschränkt sich durch aktive Bauelemente auf einen bestimmten Frequenzbereich. Dieser lässt sich wie folgt berechnen:
\begin{align*}
	f_{\unit[3]{dB}} = \sqrt{\frac{GBP}{2\pi \cdot R_1 \cdot C_I}}
\end{align*}
Für unser System liegt die Bandbreite bei etwa $\unit[73]{kHz}$. Dies ist auch die Grenzfrequenz des Verstärkersystems. Die Grenzfrequenz ist die Frequenz bei der die Verstärkung auf den $\frac{1}{\sqrt{2}}$ fachen Wert der maximalen Verstärkung gesunken ist und bei der die Hälfte der maximalen Leistung an einen, rein Ohm'schen, Verbraucher abgegeben wird.



% -------------------------------------------------------------------------------------- %

\section{Detektormodul}
\label{sec:Detektormodul}

Das Detektormodul besteht lediglich aus vier Photodioden und einem USB-2A Eingang. Dadurch kann das Detektormodul an den Oktokommander angeschlossen werden. Zur Ansteuerung der Photodioden wurde auch hier ein i2c Expander verwendet. 


\subsubsection*{Konstruktion}
Die wesentlichen Bestandteile des Detektormoduls sind eine Platine, die die Elektronik aufnimmt, und eine weitere Stage für weitere Photodioden zur Detektion des reflektierten Lichts. Auch hier werden, ähnlich wie beim Oktokommander, die Stages übereinander angeordnet. In \reffig{fig:DetektorStage1} ist die Stage 1 des Detektormoduls dargestellt.

\begin{figure}[h]
	\centering
	\includegraphics[width=9cm]{../CAD_Bilder/DetektorElektronik_Stage1_raytraced.png}
	\caption{Stage 1 des Detektormoduls.}
	\label{fig:DetektorStage1}
\end{figure}

Die Stage 1 des Detektormoduls ist eine Platine mit dem male USB-Stecker und dem I2C-Expandern und sonstiger nötiger Elektronik. Darüber wird die Stage 2 mit den Fotodioden angeordnet. Stage 2 des Detektormoduls ist in \reffig{fig:DetektorStage2} dargestellt.

\begin{figure}[h]
	\centering
	\includegraphics[width=9cm]{../CAD_Bilder/Detektormodul_Stage2_raytraced.png}
	\caption{Stage 2 des Detektormoduls.}
	\label{fig:DetektorStage2}
\end{figure}

Die Stage 2 des Detektormoduls wird ebenfalls additiv gefertigt und besteht aus ABS-Kunststoff. In der Stage 2 des Detektormoduls werden vier Photodioden angebracht, ähnlich wie bei Stage 3 des Oktokommanders. Das vollständige Detektormodul ist in \reffig{fig:DetektorZusammenbau} dargestellt.

\begin{figure}[h]
	\centering
	\includegraphics[width=9cm]{../CAD_Bilder/Detektormodul_raytraced.png}
	\caption{Zusammenbau des Detektormoduls}
	\label{fig:DetektorZusammenbau}
\end{figure}

Das Gehäuse und der Deckel des Detektormoduls werden additiv aus ABS-Kunststoff gefertigt.
Der Oktokommander bietet sieben Ports für die Verbindung der Detektormodule. Oktokommander und Detektormodule zusammen bilden einen Teil der Hardware des Gestikulasers. Der Zusammenbau der Detektormodule mit dem Oktokommander ist \reffig{fig:AufsichtGestikulaser} dargestellt.

\begin{figure}[h]
	\centering
	\includegraphics[width=9cm]{../CAD_Bilder/Gestikulaser_raytraced_2.png}
	\caption{Aufsicht auf den Gestikulaser.}
	\label{fig:AufsichtGestikulaser}
	\vfill
	\includegraphics[width=9cm]{../CAD_Bilder/Gestikulaser_raytraced_4.png}
	\caption{Die Detektormodule können über USB Steckverbindungen mit dem Oktokommander verbunden werden.}
	\label{fig:Gestikulaser}
	\vfill
	\includegraphics[width=9cm]{../CAD_Bilder/Gestikulaser_raytraced.png}
	\caption{Sind alle sieben Detektormodule angesteckt, ist der Gestikulaser einsatzbereit.}
	\label{fig:Gestikulaser}
\end{figure}


% -------------------------------------------------------------------------------------- %

\section{Software}
\label{sec:Software}

Die Software-Seite des Gestikulasers ist für die Zuordnung der Gesten zuständig. Die von den Detektormodulen gemessenen Reflektionsmuster werden an den Mikrocontroller im Oktokommander und von da aus an einen Computer weitergeleitet, wo sie verarbeitet werden. Bei der dazu eingesetzten Software wurde komplett auf open-source verfügbare Programme und Bibliotheken gesetzt. Der Code auf den Microcontrollern wurde mit Hilfe der \href{https://www.arduino.cc/en/Main/Software}{\texttt{Arduino IDE}} entwickelt. Die Verarbeitung am Computer erfolgt mit Hilfe von \texttt{Python} Skripten. Für den Machine Learning Teil wurde die \href{https://www.tensorflow.org/}{\texttt{TensorFlow}\texttrademark} Bibliothek verwendet. Die Software kann in zwei Teile unterteilt werden, die im Folgenden genauer erläutert werden.

\subsubsection*{Trainingsphase}
Der erste Teil der Software kommt während der Trainingsphase zum Einsatz. Hier werden die von den Photodioden gemessenen Daten aus dem Microcontroller im Oktokommander zunächst ausgelesen und gemeinsam mit einem Label, das der gerade aufgenommenen Geste entspricht, in eine Datei geschrieben. Die auf diese Weise gesammelten Daten werden dann im nächsten Schritt verwendet, um ein mathematisches Modell zu erstellen, das im Live-Betrieb angewendet wird, um die vom Nutzer gemachte Geste, einer der bekannten zuordnen zu können. Angenommen es stehen Daten von $N$ Photodioden zur Verfügung, dann können diese Daten in dem Vektor $x\in \mathbb{R}^N$ zusammengefasst werden. Für den Anfang soll ein Modell entwickelt werden, welches einem beliebigen gemessenen Datensatz $x$ eine der $m$ vordefinierten Gesten $G_1 , ... , G_m$ zuordnet. Dazu stellt der Nutzer vor Aufzeichnung der Daten in dem Python Skript ein, was für eine Geste $G_j$ er als nächstes aufnehmen will. Nachdem für jede Geste ausreichend Daten aufgenommen wurden, kann als nächstes das mathematische Modell erstellt werden, um die Sensordaten zu verarbeiten. Ziel ist es, ein gegebenes Datum $x_i$, das im Live-Betrieb gemessen wird, eindeutig einer Geste $G_j$ zuzuordnen. Damit Datum $x_i$ der Geste $G_j$ zugeordnet wird, muss die Bedingung 
\begin{align*}
	p(G_j | x_i) \geq p(G_k | x_i) \quad \forall k = 1,...,m \quad k \neq j
\end{align*}
erfüllt sein. Dabei ist $p(G_j | x_i)$ die bedingte Wahrscheinlichkeit für Geste $G_j$ gegeben die Photomessdaten $x_i$. Diese Bedingung lässt sich leicht überprüfen, allerdings ist die bedingte Wahrscheinlichkeit $p(G | x)$ unbekannt. Aus diesem Grund wird ein neuronales Netz mit Hilfe der zuvor aufgezeichneten Daten $(x,G) \in \mathbb{R}^N \times \mathbb{R}$ trainiert, das die unbekannte bedingte Wahrscheinlichkeit annähert. Der Aufbau und das Training des neuronalen Netzes erfolgen mit Hilfe vordefinierter Methoden von \texttt{TensorFlow}\texttrademark. Nach erfolgreich abgeschlossenem Training wird das neuronale Netz in eine Datei exportiert und kann nun im Live-Betrieb verwendet werden.

\subsubsection*{Live-Betrieb}
Im Live-Betrieb wird das zuvor trainierte Modell nun verwendet, um die nun unbekannten Reflektionsmuster, die von den Photodioden gemessen und über den Mikrocontroller an den PC weitergeleitet wurden, einer bekannten Geste zuzuordnen. Nachdem die gemessenen Daten einer Geste zugeordnet wurden, wird der mit dieser Geste verknüpfte Steuerungsbefehl bestimmt und an das angeschlossene Endgerät weitergeleitet. Dieser Ablauf ist in \reffig{fig:AblaufSteuerung} dargestellt.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.75]{../figures/AblaufSteuerung.pdf}
	\caption{Ablaufdiagramm der Software im Live-Betrieb: Die aus dem Microcontroller ausgelesenen Sensordaten werden zur Verarbeitung an das Python Skript übergeben, wo sie einer Geste und diese einem Steuerbefehl zugeordnet wird. Dieser Steuerungsbefehl wird schließlich an das anzusteuernde Endgerät weitergegeben.}
	\label{fig:AblaufSteuerung}
\end{figure}